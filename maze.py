# Maze by iris
# For Recurse Center Application, June 2025
#
# Inspired by an activity described in the book
# "Right Kind of Wrong" by Amy Edmondson
# 
# Small, terminal-based game. 
# The goal of the game is for the user to find their way 
# through a maze from entry to exit as quickly as possible. 
# 
# - The maze exists within a grid of tiles.
# - Path tiles are part of the maze.
# - Wall tiles are not.
# - There is an Entry tile and an Exit tile.
# - Except for the Entry, all tiles at first obscured, 
#   and the user must step on a tile before revealing if
#   it's a path tile or wall tile.
# - The user can only step on tiles adjacent to already 
#   revealed path tiles. 
# - The user takes steps using the WASD keys.
# - Stepping on a path tile is a success.
# - Stepping on a wall tile is a failure.
# - Some path tiles lead to dead ends.
# - The game is over and the user wins when they
#   reveal the Exit tile.
#
# There is no losing, only taking longer.

# Pseudo-Structure
# I'll need...
# (0) An intro prompt.
# (1) To print out the maze. Initially, and after every move.
# (2) To receive user input after printing out the maze.
# (3) To process input and update the maze.
# (4) To identify the win-condition and end the game.
# 
# For all of that I'll need.
# (A) To initialize the grid. Maze, path and barrier tiles, entry, exit.
# 
# What I can start with:
# - A grid made up of all path tiles.
#
# TODO: Implement Algorithm to generate maze
# Reference: https://aryanab.medium.com/maze-generation-recursive-backtracking-5981bc5cc766
# Reference: https://inventwithpython.com/recursion/chapter11.html

import random
import time
from enum import Enum
import curses

class Direction(Enum): 
    NORTH = 1
    SOUTH = 2
    WEST = 3
    EAST = 4

class tcolors:
    """
    Helper class for printing in terminal with style
    Reference: https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal
    """
    SUCCESS = '\x1b[1;97;102m'
    FAILURE = '\x1b[1;37;41m'
    REVEALED = '\x1b[0;36;107m'
    HIDDEN = '\x1b[0;90;40m'
    ENDC = '\x1b[0m'

class Mystery_Maze:
    """
    A mystery maze is made up of a grid and a shroud.
    The grid is the underlying maze, where each tile is either a WALL or PATH.
    The grid is generated by recursive backtracking.
    The shroud makes our game playable. It hides the grid from view, revealing
    each cell only after the player has stepped on it.
    """

    # Constants for displaying maze
    PATH = tcolors.REVEALED + ' ' + tcolors.ENDC
    MARK_SUCCESS = tcolors.SUCCESS + '@' + tcolors.ENDC
    MARK_FAILURE = tcolors.FAILURE + '@' + tcolors.ENDC
    WALL = tcolors.REVEALED + chr(9608) + tcolors.ENDC
    HIDDEN = tcolors.HIDDEN + chr(9608) + tcolors.ENDC

    def __init__(self, width, height):

        # Ensure width and height are odd and sufficiently large
        if (width < 3):
            width = 3
        elif (width % 2 != 1):
            width += 1
        self.width = width

        if (height < 3):
            height = 3
        elif (height % 2 != 1):
            height += 1
        self.height = height

        SEED = 3
        random.seed(SEED)

        # Initialize grid data structure where every tile is a wall.
        self.grid = {}
        for x in range(width):
            for y in range(height):
                self.grid[(x,y)] = self.WALL
    
        # Begin recursive maze generation, which carves out a maze
        # of paths in the the tiles
        self.has_carved = []
        self.carve_tile((1,1))

        # Add entrance and exit to maze.
        self.exit = (1,0)
        self.entrance = (self.width - 2, self.height - 1)

        self.grid[self.exit] = self.PATH
        self.grid[self.entrance] = self.PATH

        # Initialize shroud data structure where every tile is hidden.
        self.shroud = {}
        for x in range(width):
            for y in range(height):
                self.shroud[(x,y)] = self.HIDDEN

        # Initialize initial player position as entrance
        self.player_position = (self.width - 2, self.height)
        self.step(Direction.NORTH)
    
    def step(self, direction):
        """Reveals the tile under mark_coords."""

        # Calculate coordinates for step from direction
        (x,y) = self.player_position
        if direction == Direction.NORTH:
            step_coords = (x, y - 1)
        elif direction == Direction.SOUTH:
            step_coords = (x, y + 1)
        elif direction == Direction.WEST:
            step_coords = (x - 1, y)
        elif direction == Direction.EAST:
            step_coords = (x + 1, y)

        # Do nothing if ilegally stepping outside of grid
        (step_x, step_y) = step_coords
        if step_x < 0 or step_x >= self.width or step_y < 0 or step_y >= self.height:
            self.display_game()
            return
        
        # Legal move. Update shroud. Change HIDDEN to whichever
        # of WALL or PATH is the underlying grid value
        self.shroud[step_coords] = self.grid[step_coords]

        # Move player
        self.player_position = step_coords

        # Display current state of the game.
        self.display_game()

        # If stepped onto wall, wait a second and return player to original position
        if self.grid[step_coords] == self.WALL:
            time.sleep(0.5)
            self.player_position = (x,y)
            self.display_game()
            return


    def display_game(self):
        """Displays the current state of the game."""

        (mark_x, mark_y) = self.player_position

        for y in range(self.height):
            for x in range(self.width):
                if mark_x == x and mark_y == y:
                    if self.grid[x,y] == self.WALL:
                        print(self.MARK_FAILURE, end='')
                    else:
                        print(self.MARK_SUCCESS, end='')
                else:
                    print(self.shroud[x,y], end='') #will be one of HIDDEN, WALL, or PATH
            print() #newline after each row

        print() #newline after entire grid

    def display_grid(self):
        """Displays the grid, or underlying maze."""

        for y in range(self.height):
            for x in range(self.width):
                print(self.grid[x,y], end='') #WALL or PATH
            print() #newline after each row

        print() #newline after entire grid

    def carve_tile(self, coords):
        """Based off recursive backtracking maze generation
        algorithm.
        
        Reference: https://inventwithpython.com/recursion/chapter11.html
        
        Carve out a cell as part of the path in the maze at x, y
        and then recursively move to neighboring unvisited
        spaces. This function backtracks when the mark has
        reached a dead end."""

        #Carve out space where there was once a wall
        self.grid[coords] = self.PATH 
        
        #Mark as visited.
        self.has_carved.append(coords)

        (x,y) = coords

        while True:
            #Check which neighbors not yet visited
            unvisited_neighbors = []
            if y > 1 and (x, y - 2) not in self.has_carved:
                unvisited_neighbors.append(Direction.NORTH)

            if y < self.height - 2 and (x, y + 2) not in self.has_carved:
                unvisited_neighbors.append(Direction.SOUTH)

            if x > 1 and (x - 2, y) not in self.has_carved:
                unvisited_neighbors.append(Direction.WEST)

            if x < self.width - 2 and (x + 2, y) not in self.has_carved:
                unvisited_neighbors.append(Direction.EAST)

            if len(unvisited_neighbors) == 0:
                # Base case: All neighbors visited.
                # Dead end. Backtrack to an earlier space.
                return
            else:
                # Recursive case:
                # Randomly pick an unvisited neighbor to visit
                
                next_tile_direction = random.choice(unvisited_neighbors)

                if next_tile_direction == Direction.NORTH:
                    next_tile_coords = (x, y - 2)
                    hallway_coords = (x, y - 1)
                elif next_tile_direction == Direction.SOUTH:
                    next_tile_coords = (x, y + 2)
                    hallway_coords = (x, y + 1)
                elif next_tile_direction == Direction.WEST:
                    next_tile_coords = (x - 2, y)
                    hallway_coords = (x - 1, y)
                elif next_tile_direction == Direction.EAST:
                    next_tile_coords = (x + 2, y)
                    hallway_coords = (x + 1, y)
                
                # Carve out the connection hallway too
                self.grid[hallway_coords] = self.PATH

                # Visit the next coordinate recursively
                self.carve_tile(next_tile_coords)


# Initialize a maze
maze = Mystery_Maze(5,5)

while True:
    prompt = """
    Use the WASD keys to make your way through the maze.
    Press a direction key and then Enter:"""
    str_input = input(prompt).lower()
    match str_input:
        case "w":
            maze.step(Direction.NORTH)
        case "a":
            maze.step(Direction.WEST)
        case "s":
            maze.step(Direction.SOUTH)
        case "d":
            maze.step(Direction.EAST)
        case _:
            print("Not a Valid direction")

